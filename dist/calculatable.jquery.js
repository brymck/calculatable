/*!
Calculatable is best
by Bryan McKelvey

Version 0.0.1
Full source at https://github.com/brymck/calculatable
Copyright (c) 2014-2014 Bryan McKelvey

MIT License, https://github.com/brymck/calculatable/blob/master/LICENSE
This file is generated by 'grunt build'. Do not edit it by hand.
*/

var Keybindings, emacs, vim,
  __hasProp = {}.hasOwnProperty;

Keybindings = (function() {
  var CHARS, code, range, _i, _j, _k, _len, _len1, _ref, _results;

  CHARS = {
    8: 'BS',
    9: 'Tab',
    13: 'Enter',
    27: 'Esc',
    37: 'Down',
    38: 'Up',
    39: 'Right',
    40: 'Left'
  };

  _ref = [
    [49, 50, 51, 52, 53, 54, 55, 56, 57], (function() {
      _results = [];
      for (_j = 65; _j <= 90; _j++){ _results.push(_j); }
      return _results;
    }).apply(this)
  ];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    range = _ref[_i];
    for (_k = 0, _len1 = range.length; _k < _len1; _k++) {
      code = range[_k];
      CHARS[code] = String.fromCharCode(code);
    }
  }

  function Keybindings(options) {
    if (options == null) {
      options = function() {
        return {};
      };
    }
    this.options = options.apply(this);
  }

  Keybindings.prototype.applyTo = function($node) {
    var bindings, nodeName, _ref1, _results1;
    _ref1 = this.options;
    _results1 = [];
    for (nodeName in _ref1) {
      if (!__hasProp.call(_ref1, nodeName)) continue;
      bindings = _ref1[nodeName];
      _results1.push($node.on('keydown', nodeName, (function(_this) {
        return function(event) {
          var fn, key;
          key = _this.toKeystring(event);
          fn = bindings[key];
          if (fn != null) {
            event.preventDefault();
            return fn.call(_this, $(event.target));
          }
        };
      })(this)));
    }
    return _results1;
  };

  Keybindings.prototype.moveLeft = function($node) {
    return this._focus($node.parent().prevAll(':has(input)'));
  };

  Keybindings.prototype.moveRight = function($node) {
    return this._focus($node.parent().nextAll(':has(input)'));
  };

  Keybindings.prototype.moveDown = function($node) {
    var index, td, tr;
    td = $node.parent();
    tr = td.parent().next();
    if (tr == null) {
      return;
    }
    index = td.prevAll().length;
    return this._focus(tr.children().eq(index));
  };

  Keybindings.prototype.moveUp = function($node) {
    var index, td, tr;
    td = $node.parent();
    tr = td.parent().prev();
    if (tr == null) {
      return;
    }
    index = td.prevAll().length;
    return this._focus(tr.children().eq(index));
  };

  Keybindings.prototype.paste = function($node) {
    return $node;
  };

  Keybindings.prototype.toKeystring = function(event) {
    var char, mods;
    char = CHARS[event.which];
    if (char == null) {
      return null;
    }
    mods = '';
    if (event.metaKey) {
      mods += 'M-';
    }
    if (event.ctrlKey) {
      mods += 'C-';
    }
    if (event.altKey) {
      mods += 'A-';
    }
    if (event.shiftKey) {
      mods += 'S-';
    }
    return mods + char;
  };

  Keybindings.prototype._focus = function($nodes) {
    return $nodes.first().children('input').focus().select();
  };

  return Keybindings;

})();

emacs = new Keybindings(function() {
  return {
    input: {
      'C-B': this.moveLeft,
      'C-F': this.moveRight,
      'C-N': this.moveDown,
      'C-P': this.moveUp,
      'C-V': this.paste
    }
  };
});

vim = new Keybindings(function() {
  return {
    td: {
      'H': this.moveLeft,
      'L': this.moveRight,
      'J': this.moveDown,
      'K': this.moveUp,
      'P': this.paste
    }
  };
});

//

var $, Calculatable;

$ = jQuery;

$.fn.extend({
  calculatable: function(options) {
    return this.each(function(input) {
      var $this, calculatable;
      $this = $(this);
      calculatable = $this.data('calculatable');
      if (!(calculatable instanceof Calculatable)) {
        return $this.data('calculatable', new Calculatable($this, options));
      }
    });
  }
});

Calculatable = (function() {
  function Calculatable(table, options) {
    this.options = options != null ? options : {};
    this.$table = $(table);
    this.setDefaultValues();
  }

  Calculatable.prototype.setDefaultValues = function() {
    return this.keybindings = false;
  };

  Calculatable.prototype.keys = function() {
    return this.$table.find('thead tr th').map((function(_this) {
      return function(_, th) {
        return _this._camelCase($(th).text());
      };
    })(this));
  };

  Calculatable.prototype.serialize = function() {
    var keys;
    keys = this.keys();
    return this.$table.find('tbody tr').map(function(_, tr) {
      var hash, i, key, values, _i, _len;
      values = $(tr).find('td').map(function(_, td) {
        return $(td).find('input').val();
      });
      hash = {};
      for (i = _i = 0, _len = keys.length; _i < _len; i = ++_i) {
        key = keys[i];
        hash[key] = values[i];
      }
      return hash;
    });
  };

  Calculatable.prototype._camelCase = function(str) {
    str = str.charAt(0).toLowerCase() + str.slice(1);
    return str.replace(/\s+/g, '');
  };

  return Calculatable;

})();

//

//# sourceMappingURL=calculatable.jquery.js.map